#include <string>
#include <sstream>
#include <iostream>
#include <fstream>
#include <vector>

using namespace std;
#include <cstdlib>
#include <math.h>
#include <assert.h>
#include <stdio.h>
#include <bitset>
#include <boost/filesystem.hpp>
#include <boost/multiprecision/cpp_int.hpp>

using namespace boost::multiprecision;





uint128_t list_to_int(uint8_t lst[], int size) {
    uint128_t result = 0;
    for (int i = 0; i < size; i++) {
        result += (uint128_t)lst[i] << (i * 8);
    }
    return result;
} 

char* int_to_list(unsigned long num) {
    char* result = new char[8];
    for (int i = 0; i < 8; i++) {
        result[i] = (num >> (i * 8)) & 0xFF;
    }
    return result;
}

void write_to_file(const string filename, long start_pos)
{
    ofstream outf;

    outf.open(filename, ios::out | ios::binary | ios::ate | ios::in);
    if (outf.fail()) { return; }

    
    outf.seekp(start_pos);
    unsigned long alpha = 1;
    unsigned long x1 = 1;
    outf.seekp(start_pos);
    outf.write(int_to_list(x1), 8);
    outf.seekp(start_pos + 8*2);
    outf.write(int_to_list(alpha), 8);

    if (outf.fail())
        throw runtime_error("failed writing to " + filename);

    outf.close();
}

void print_file(const string filename, int size)
{
    ifstream inf;
    int end_posn = 0;
    int start_posn = 0;
    
    inf.open(filename, ios::in | ios::binary);
    if (inf.fail()) { return; }
    
    auto data_start = inf.tellg();

    int size_in_bytes = sizeof(long)*size;
    int n_read = 0;
    char read_buffer[size_in_bytes];
    inf.seekg(start_posn * sizeof(int), iostream::cur);
    do
    {
        inf.read(read_buffer + n_read, size_in_bytes - n_read);
        n_read += inf.gcount();

        if (inf.eof())
        {
            stringstream ss;
            ss << "Got to EOF when reading from disk (expecting " << size_in_bytes
                << " bytes from " << (long(data_start) + start_posn * sizeof(int))
                << ").";
            std::cout << ss.str() << "\n";
            return;
        }
        if (inf.fail())
        {
            stringstream ss;
            ss << "IO problem when reading from disk";
            std::cout << ss.str() << "\n";
            return;
        }
    }
    while (n_read < size_in_bytes);

    end_posn = (inf.tellg() - data_start) / sizeof(int);

    //Check if at end of file by getting 1 more char.
    inf.get();
    if (inf.eof())
        end_posn = -1;
    inf.close();
    
    int start = 0;
    cout << "Printing file: " << filename << "\n";
    cout << "Meta data: " << "\n";
    for (int i = 1; i <= 8*size; i++) {
        cout << bitset<8> ((read_buffer[(i+start)])) << " ";
        if (i % 8 == 0) {
            cout << "\n";
        }
        if (i == 8*3) {
            cout << "Share:" << "\n";
        }
        if (i == 8*4) {
            cout << "Tag:" << "\n";
        }
        //std::cout << (int)temp << " ";
    }
    return;
}


uint128_t read_from_file(const string filename, const int start_posn, int &end_posn)
{
    ifstream inf;
    
    int size = 16;
    
    inf.open(filename, ios::in | ios::binary);
    if (inf.fail()) { return 0; }
    
    auto data_start = inf.tellg();

    int size_in_bytes = size;
    int n_read = 0;
    char read_buffer[size_in_bytes];
    inf.seekg(start_posn+1, iostream::cur);
    do
    {
        inf.read(read_buffer + n_read, size_in_bytes - n_read);
        n_read += inf.gcount();

        if (inf.eof())
        {
            stringstream ss;
            ss << "Got to EOF when reading from disk (expecting " << size_in_bytes
                << " bytes from " << (long(data_start) + start_posn * sizeof(int))
                << ").";
            std::cout << ss.str() << "\n";
            return 0;
        }
        if (inf.fail())
        {
            stringstream ss;
            ss << "IO problem when reading from disk";
            std::cout << ss.str() << "\n";
            return 0;
        }
    }
    while (n_read < size_in_bytes);

    end_posn = (inf.tellg() - data_start) ;

    //Check if at end of file by getting 1 more char.
    inf.get();
    if (inf.eof())
        end_posn = -1;
    inf.close();
    uint8_t share[size];
    for (int i = 0; i < size; i++) {
        uint8_t temp = (uint8_t)((read_buffer[(i)]));
        share[i] = temp;

        //std::cout << (int)temp << " ";
    }
    return list_to_int(share, size);
}

void share_and_tag(int share_num) {
    int end_file_posn = 0;
    string filename1 = "Persistence/Transactions-P0.data";
    string filename2 = "Persistence/Transactions-P1.data";
    int start_file_posn = 3*8 + share_num * 4*8;
    uint128_t x1 = read_from_file(filename1, start_file_posn, end_file_posn);
    uint128_t x2 = read_from_file(filename2, start_file_posn, end_file_posn);
    uint128_t t1 = read_from_file(filename1, start_file_posn+16, end_file_posn);
    uint128_t t2 = read_from_file(filename2, start_file_posn+16, end_file_posn);
    uint128_t alpha = 3041996936556572527;
    cout << "Share data for share number " << share_num << "\n";
    cout << "Share P0: " << x1  << "\n";
    cout << "Share P1: " << x2  << "\n";
    cout << "Tag P0: " << t1  << "\n";
    cout << "Tag P1: " << t2  << "\n";
    cout << "Secret: " << x1+x2  << "\n";
    cout << "Tag: " << t1+t2   << "\n";
    cout << "Alpha * Secret = " << alpha * (x1+x2) << "\n";
    
}

int main(int argc, char *argv[]) {
    share_and_tag(0); // First share written to file 
}






